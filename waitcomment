#!/bin/bash
if [[ $(/usr/bin/id -u) -ne 0 ]]; then
    echo "Not running as root"
    exit
fi
# Grabs the last two lines of the sudo logfile (my location) to tmpfile.
tail -n2 /var/log/sudo.log > /tmp/comment.tmp
curr_command="$(tail -n1 /tmp/comment.tmp)"
curr_shell="$(head -n1 /tmp/comment.tmp | cut -c 31-36)"
# List of commands to be commented. Can be customized. There's definitely a more elegant way to do this. 
if grep -qE '=/usr/bin/visudo|=/usr/bin/vim|=/usr/bin/rm|=/usr/bin/rmdir|=/usr/bin/mkdir|=/usr/bin/trash-put|=/usr/bin/cp|=/usr/bin/touch|=/usr/bin/mv|=/usr/bin/chmod|=/usr/bin/chown|=/usr/bin/pacman -S |=/usr/bin/pacman -R|>' <<< $curr_command; then
	# Keeps sudo-comment from triggering itself in certain situations.
	if grep -q -v '/tmp/comment.tmp' <<< $curr_command; then
		sleep 0.5
		# Waits until no processes running in foreground on given shell except bash or sudo. Causes some problems with files named bash (ex. /etc/bash.bashrc). Should use something
		# other than grep but I'll figure it out later.
		until [ `ps ax | grep -v "bash" | grep -v "sudo -s" | grep -v "sudo -i" | awk '$3 ~ /\+/' | awk -v shell=$curr_shell '$2 ~ shell' | wc -l` == 0 ]
		do 
			sleep 0.1
		done
		chmod 666 /tmp/comment.tmp
		# Pushes "addcomment" with a newline to the shell.
		ttyecho -n /dev/$curr_shell 'addcomment'
		# Waits until addcomment has exited.
		until [ `ps ax | grep "addcomment" | awk '$3 ~ /\+/' | awk -v shell=$curr_shell '$2 ~ shell' | wc -l` == 0 ]
		do
			sleep 0.1
		done
		# Appends tmpfile to the comment log.
		cat /tmp/comment.tmp >> /var/log/comment.log
		rm /tmp/comment.tmp
	fi
else
	rm /tmp/comment.tmp
fi
